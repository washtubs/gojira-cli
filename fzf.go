package cli

import (
	"bytes"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"strconv"
	"strings"

	"github.com/pkg/errors"
)

// responsible for selecting
// actionBases
// issues

type SelectOptions struct {
	Prompt  string
	One     bool
	Exclude int // exclude this many fields from the left generated by the formatter
}

func formatterSliceToChan(formatters []Formatter) chan Formatter {
	channel := make(chan Formatter, len(formatters))
	for _, f := range formatters {
		channel <- f
	}
	close(channel)
	return channel
}

func FzfSelect(candidates []Formatter, opts SelectOptions, rpcPort int) ([]int, bool, error) {
	return FzfSelectChan(formatterSliceToChan(candidates), opts, rpcPort)
}

func appendFzfArgs(args []string, opts SelectOptions, rpcPort int) []string {
	args = append(args, "--with-nth", strconv.Itoa(2+opts.Exclude)+"..", "--reverse")
	if opts.One {
		args = append(args, "+m")
	}
	if opts.Prompt != "" {
		args = append(args, "--prompt="+opts.Prompt+"> ")
	}

	if rpcPort != 0 { // RPC supported
		args = append(args, "--preview", "gojira-cli _rpc print {} | fold -w 80")
		args = append(args, "--bind", "f1:execute(gojira-cli _rpc load)")
	}

	return args

}

func FzfSelectChan(c <-chan Formatter, opts SelectOptions, rpcPort int) ([]int, bool, error) {
	args := appendFzfArgs(make([]string, 0), opts, rpcPort)
	cmd := exec.Command("fzf-tmux", args...) // TODO figure out why I have to use fzf-tmux instead of fzf

	if rpcPort != 0 { // RPC supported
		cmd.Env = os.Environ()
		SetupEnvForRpc(cmd, rpcPort)
	}

	// Collect all output in a buffer
	var stdout *bytes.Buffer
	outPipe, err := cmd.StdoutPipe()
	if err != nil {
		panic(err)
	}

	inR, inW := io.Pipe()
	cmd.Stdin = inR

	err = cmd.Start()
	if err != nil {
		return nil, false, errors.Wrap(err, "error starting command")
	}

	cancel := make(chan bool, 1)
	go fzfWrite(c, inW, cancel)

	go func() {

		// When Fzf closes stdout,
		// we need to cancel the formatters stream,
		// and close stdin,
		// so Wait() will finish
		out, err := ioutil.ReadAll(outPipe)
		if err != nil {
			log.Println(err)
			return
		}

		stdout = bytes.NewBuffer(out)
		cancel <- true
	}()

	err = cmd.Wait()

	if err != nil {
		return nil, true, nil
	}

	indexes := fzfConvertOutput(stdout.String())

	return indexes, false, nil
}

func fzfConvertOutput(out string) []int {

	// convert full string results into indexes
	results := strings.Split(out, "\n")
	indexes := make([]int, 0, len(results))
	for _, result := range results {
		if result == "" {
			continue
		}
		idx, err := strconv.Atoi(strings.Fields(result)[0])
		if err != nil {
			panic(err)
		}

		indexes = append(indexes, idx)
	}
	return indexes
}

func fzfWrite(c <-chan Formatter, inW io.WriteCloser, cancel <-chan bool) error {
	line := 0
	buf := bytes.NewBuffer([]byte{})
	for {
		select {
		case formatter, more := <-c:
			if !more {
				inW.Close()
				return nil
			}
			_, err := buf.WriteString(strconv.Itoa(line) + " " + formatter.Format() + "\n")
			if err != nil {
				return err
			}

			_, err = buf.WriteTo(inW)
			if err != nil {
				return err
			}

			line = line + 1
		case <-cancel:
			inW.Close()
			return nil
		}
	}
}
